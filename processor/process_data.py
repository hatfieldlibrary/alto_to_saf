import os
import shutil
import sys
from pathlib import Path
from zipfile import ZipFile

from config import metadata
from processor.mets.make_mets import create_mets_file
from processor.saf.make_saf import mets_to_saf


def process_files(input_dir: str, output_dir: str, config: str, bundle: str, strip: str):
    """
    Initiates processing of abbyy output files.

    :param input_dir: input directory of files generated by abbyy
    :param output_dir: the base directory of the output directories for saf and mets/alto
    :param config: metadata configuration used to create METS file
    :param bundle: the bundle that contain will image files - optional
    :param strip: prefix to strip from file names (e.g.: Page_) -optional
    :return: void
    """
    create_output_mets_directory(output_dir)

    path = Path(input_dir)
    config = metadata.collection_metadata_configs[config]

    if not path.exists():
        raise ValueError(f"The provided input directory does not exist '{path}'.")

    for dir_path, dir_names, files in os.walk(input_dir):
        for directory in dir_names:
            print(f'\nProcessing files in the directory: {path}/{directory}')
            # new path for subdirectory
            path = Path(dir_path + '/' + directory)
            sub_dir = output_dir + '/' + directory
            # process files in subdirectory
            process_sub_directory_files(path, sub_dir, config, strip, bundle)

    print('Creating zip file.\n')

    archive = output_dir + '/mets_saf_output.zip'

    file_paths = get_all_file_paths(output_dir)
    with ZipFile(archive,'w') as zipper:
        # writing each file one by one
        for file in file_paths:
            p = Path(file)
            arcname = os.path.join(*p.parts[-3:])
            zipper.write(file, arcname)

    print(f'Zip archive written to: {archive}\n')

    print('FINISHED\n')


def process_sub_directory_files(path: Path, output_dir: str, config: dict, strip: str, bundle: str):
    """
    Processes files in a subdirectory, creating output directories for mets/alto and saf.
    :param path: file system Path object
    :param output_dir: the output directory for this subdirectory
    :param config: metadata configuration used to create METS file
    :param strip: prefix to strip from file names (e.g.: Page_) -optional
    :param bundle: the bundle that contain will image files - optional
    :return: void
    """
    local_config = config.copy()
    # update the local dictionary of metadata with user input
    print('\nENTER THE ITEM METADATA. This information will be added to the METS file.\n')
    for key in local_config.keys():
        if local_config[key]:
            value = input(f"{key} (hit enter to accept default: {local_config[key]}) ") or local_config[key]
            local_config[key] = value
        else:
            value = input(f'{key}: ') or ''
            local_config[key] = value

    print('\nMetadata for this item:\n')

    # display metadata
    for key in local_config.keys():
        if local_config[key]:
            print(f'{key}: {local_config[key]}')

    # the user can continue or cancel
    check = input('\nHit enter to begin processing or "x" to cancel ')
    if check.lower() == 'x':
        sys.exit('Processing cancelled.\n')

    filenames = set([])

    # create output directory
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    mets_dir = output_dir + '/' + 'mets_alto'
    saf_dir = output_dir + '/' + 'saf'
    if not os.path.exists(mets_dir):
        os.makedirs(mets_dir)

    for file in path.glob('*'):  # recursively list directories and files
        if file.is_file():  # check if it's a file

            # skip . files,e.g. .DS_Store, Thumbs.db
            if file.name.startswith('.') or file.name.startswith('Thumbs'):
                continue
            # remove file name prefix if required
            if strip:
                file_name = file.name.replace(strip, '')
            else:
                file_name = file.name

            # add to the set of file names without extensions
            filenames.add(file_name.replace(file.suffix, ''))

            # update the JPEG2000 extension
            if file.suffix == '.j2k':
                new_file_name = file_name.replace('j2k', 'jp2')
                shutil.copy(file, mets_dir + '/' + new_file_name)

            # exclude pdf files
            elif file.suffix != '.pdf':
                shutil.copy(file, mets_dir + '/' + file_name)

    # ordered list of file names without extensions.
    file_names_list = list(sorted(filenames))

    # generate the mets file
    create_mets_file(mets_dir, local_config, file_names_list)
    print(f'All files copied to {mets_dir}')

    # create saf directory
    generate_saf(mets_dir, saf_dir, bundle)

    print('Processing complete.')


def generate_saf(input_dir, saf_dir, bundle):
    print(f'\nGenerating SAF directory in {saf_dir}')
    mets_to_saf(input_dir, saf_dir, bundle)
    print(f'SAF directory created in {saf_dir}\n')


def create_output_mets_directory(mets_directory):
    os.mkdir(mets_directory)


def get_all_file_paths(directory):

    # initializing empty file paths list
    file_paths = []

    # crawling through directory and subdirectories
    for root, directories, files in os.walk(directory):
        for filename in files:
            # join the two strings in order to form the full filepath.
            filepath = os.path.join(root, filename)
            file_paths.append(filepath)

    # returning all file paths
    return file_paths
