import os
import shutil
import sys
from pathlib import Path
from zipfile import ZipFile

from config import metadata
from processor.mets.make_mets import create_mets_file
from processor.saf.make_saf import to_saf


def process_files(input_dir: str, output_dir: str, config: str, bundle: str, strip: str):
    """
    Initiates processing of abbyy output files.

    :param input_dir: input directory of files generated by abbyy
    :param output_dir: the base directory of the output directories for saf and mets/alto
    :param config: metadata configuration used to create METS file
    :param bundle: the bundle that contain will image files - optional
    :param strip: prefix to strip from file names (e.g.: Page_) -optional
    :return: void
    """
    create_output_mets_directory(output_dir)

    path = Path(input_dir)
    config = metadata.collection_metadata_configs[config]

    if not path.exists():
        raise ValueError(f"The provided input directory does not exist '{path}'.")

    for dir_path, dir_names, files in os.walk(input_dir):
        dirs = sorted(dir_names)
        for directory in dirs:
            print(f'\nProcessing files in the directory: {path}/{directory}')
            # new path for subdirectory
            path = Path(dir_path + '/' + directory)
            sub_dir = output_dir + '/' + directory
            # process files in subdirectory
            process_sub_directory_files(path, sub_dir, config, strip, bundle)

    print('\nCreating zip file.\n')

    archive = output_dir + '/saf_output.zip'

    file_paths = get_all_file_paths(output_dir)

    with ZipFile(archive, 'w') as zipper:
        # writing each file one by one
        for file in file_paths:
            p = Path(file).parts
            arcname = os.path.join('saf-import', p[-3], p[-1])
            zipper.write(file, arcname)

    print(f'SAF zip archive written to: {archive}\n')

    print('FINISHED\n')


def process_sub_directory_files(path: Path, output_dir: str, config: dict, strip: str, bundle: str):
    """
    Processes files in a subdirectory, creating output directories for mets/alto and saf.
    :param path: file system Path object
    :param output_dir: the output directory for this subdirectory
    :param config: metadata configuration used to create METS file
    :param strip: prefix to strip from file names (e.g.: Page_) -optional
    :param bundle: the bundle that contain will image files - optional
    :return: void
    """
    local_config = config.copy()
    # The output directory for unzipped SAF files
    saf_output_dir = 'saf_import_files_unzipped'

    print('\nENTER THE ITEM METADATA. This information will be added to the METS file.\n')
    for key in local_config.keys():
        if local_config[key]:
            value = input(f" * {key} (hit enter to accept default: {local_config[key]}) ") or local_config[key]
            local_config[key] = value
        else:
            value = input(f' * {key}: ') or ''
            local_config[key] = value

    print('\nMetadata for this item:\n')

    # display metadata to the user
    for key in local_config.keys():
        # this is a potentially common mistake caused hitting a control key while entering data.
        bad_chars = '^['
        if not any(c in bad_chars for c in local_config[key]):
            print(f'{key}: {local_config[key]}')
        else:
            print(f'ERROR: {key} contains invalid characters (^ or [). Please abort and try again.\n')
            sys.exit('Processing cancelled.\n')

    # the user can continue or cancel processing
    check = input('\nHit enter to begin processing or "x" to cancel ')
    if check.lower() == 'x':
        sys.exit('Processing cancelled.\n')

    filenames = set([])

    # create output directory
    if not os.path.exists(output_dir):
        os.makedirs(output_dir)
    mets_alto_dir = output_dir + '/' + 'mets_alto'
    saf_dir = output_dir + '/' + saf_output_dir
    if not os.path.exists(mets_alto_dir):
        os.makedirs(mets_alto_dir)

    files = path.glob('*')
    for file in sorted(files):  # recursively list directories and files
        if file.is_file():  # check if it's a file

            # Skip . files,e.g. .DS_Store, Thumbs.db
            if file.name.startswith('.') or file.name.startswith('Thumbs'):
                continue
            # Remove file name prefix if required
            if strip:
                file_name = file.name.replace(strip, '')
            else:
                file_name = file.name

            # Add to the set of file names. The set will be used when
            # generating the METS file. Drop the file extension.
            filenames.add(file_name.replace(file.suffix, ''))

            # Update the JPEG2000 extension and copy to the output mets/alto directory
            if file.suffix == '.j2k':
                new_file_name = file_name.replace('j2k', 'jp2')
                copy_to_mets_alto_dir(file, mets_alto_dir + '/' + new_file_name)

            # Copy other files to the output mets/alto directory, excluding the single page pdf files
            elif file.suffix != '.pdf':
                copy_to_mets_alto_dir(file, mets_alto_dir + '/' + file_name)

    # Create an ordered list of file names.
    file_names_list = list(sorted(filenames))

    # Generate the METS file based on the provided metadata and the list of file names.
    # The METS file is written to the mets_alto directory.
    create_mets_file(mets_alto_dir, local_config, file_names_list)
    print(f'All files copied to {mets_alto_dir}')

    # Create files in the output saf directory.
    generate_saf(mets_alto_dir, saf_dir, bundle)

    print('Processing complete.')


def generate_saf(input_dir, saf_dir, bundle):
    print(f'\nGenerating SAF files in {saf_dir}')
    to_saf(input_dir, saf_dir, bundle)
    print(f'SAF import created in {saf_dir}\n')


def create_output_mets_directory(mets_directory):
    os.mkdir(mets_directory)


def get_all_file_paths(directory):
    # initializing empty file paths list
    file_paths = []

    # crawling through directory and subdirectories
    for root, directories, files in os.walk(directory):
        if 'saf_import_files_unzipped' in root:
            for filename in files:
                # join the two strings in order to form the full filepath.
                filepath = os.path.join(root, filename)
                file_paths.append(filepath)

    # returning all file paths
    return file_paths


def copy_to_mets_alto_dir(file_location, file_destination):
    try:
        shutil.copy(file_location, file_destination)
    except shutil.Error as e:
        print(f"Error occurred during copying: {e}")
    except FileNotFoundError:
        print("Source file not found.")
    except PermissionError:
        print("Permission denied while copying.")